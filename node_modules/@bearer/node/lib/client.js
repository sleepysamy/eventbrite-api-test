"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const winston_1 = require("winston");
const auth_details_1 = require("./auth-details");
const { combine, timestamp, label, prettyPrint } = winston_1.format;
const DEFAULT_TIMEOUT = 5 * 1000; // 5 seconds
const pkg = require('../package.json');
const userAgent = `Bearer-Node (${pkg.version})`;
// TODO: write documentation
class Bearer {
    constructor(secretKey, options) {
        this.options = {
            authHost: 'https://auth.bearer.sh',
            host: 'https://proxy.bearer.sh',
            httpClientSettings: { timeout: DEFAULT_TIMEOUT }
        };
        this.options = Object.assign(Object.assign({}, this.options), options);
        this.secretKey = secretKey;
    }
    integration(integrationId, httpClientSettings = { timeout: DEFAULT_TIMEOUT }) {
        this.options.httpClientSettings = Object.assign(Object.assign({}, this.options.httpClientSettings), httpClientSettings);
        return new BearerClient(integrationId, this.options, this.secretKey);
    }
}
exports.bearer = Bearer;
class BearerClient {
    constructor(integrationId, options, secretKey, setupId, authId) {
        this.integrationId = integrationId;
        this.options = options;
        this.secretKey = secretKey;
        this.setupId = setupId;
        this.authId = authId;
        this.client = axios_1.default;
        this.loggerTransports = {
            console: new winston_1.transports.Console({ level: 'info' })
        };
        this.logger = winston_1.createLogger({
            format: combine(label({ label: 'bearer' }), timestamp(), prettyPrint()),
            transports: [this.loggerTransports.console]
        });
        this.auth = (authId) => {
            return new BearerClient(this.integrationId, this.options, this.secretKey, this.setupId, authId);
        };
        this.setup = (setupId) => {
            return new BearerClient(this.integrationId, this.options, this.secretKey, setupId, this.authId);
        };
        this.authenticate = this.auth; // Alias
        /**
         * `getAuth` retrieve the auth information (eg. access token) for the current identity.
         *
         * You must call `auth` prior to calling this function
         */
        this.getAuth = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.authId) {
                throw new MissingAuthId();
            }
            const url = `${this.options.authHost}/apis/${this.integrationId}/auth/${this.authId}`;
            const response = yield this.client.get(url, {
                headers: {
                    Authorization: this.secretKey,
                    'User-Agent': userAgent
                }
            });
            return auth_details_1.translateAuthDetails(response.data);
        });
        /**
         * HTTP methods
         */
        this.get = (endpoint, parameters, options) => {
            return this.request('GET', endpoint, parameters, options);
        };
        this.head = (endpoint, parameters, options) => {
            return this.request('HEAD', endpoint, parameters, options);
        };
        this.post = (endpoint, parameters, options) => {
            return this.request('POST', endpoint, parameters, options);
        };
        this.put = (endpoint, parameters, options) => {
            return this.request('PUT', endpoint, parameters, options);
        };
        this.delete = (endpoint, parameters, options) => {
            return this.request('DELETE', endpoint, parameters, options);
        };
        this.patch = (endpoint, parameters, options) => {
            return this.request('PATCH', endpoint, parameters, options);
        };
        this.request = (method, endpoint, parameters, options) => {
            if (parameters && typeof parameters !== 'object') {
                throw new InvalidRequestOptions();
            }
            const preheaders = {
                Authorization: this.secretKey,
                'User-Agent': userAgent,
                'Bearer-Auth-Id': this.authId,
                'Bearer-Setup-Id': this.setupId
            };
            if (parameters && parameters.headers) {
                for (const key in parameters.headers) {
                    preheaders[key] = parameters.headers[key];
                }
            }
            const headers = Object.keys(preheaders).reduce((acc, key) => {
                const header = preheaders[key];
                if (header !== undefined && header !== null) {
                    acc[key] = preheaders[key];
                }
                return acc;
            }, {});
            const baseURL = `${this.options.host}/${this.integrationId}`;
            const requestParams = parameters && parameters.query;
            const payload = parameters && parameters.body;
            this.logger.debug('sending request', {
                method,
                headers,
                baseURL,
                url: endpoint,
                params: requestParams,
                data: payload
            });
            return this.client.request({
                method,
                headers,
                baseURL,
                url: endpoint,
                params: requestParams,
                data: payload
            });
        };
        if (this.options.timeout) {
            console.warn('DEPRECATION WARNING: Please use `httpClientSettings`. `timeout` is deprecated');
        }
        this.client = axios_1.default.create(Object.assign({ timeout: this.options.timeout || DEFAULT_TIMEOUT }, this.options.httpClientSettings));
        this.client.interceptors.response.use((response) => {
            const requestId = response.headers['bearer-request-id'];
            this.logger.info(`request id: ${requestId}`);
            return response;
        });
    }
}
exports.BearerClient = BearerClient;
/**
 * Errors handling
 */
class InvalidAPIKey extends Error {
    constructor(token) {
        super(`Invalid Bearer API key provided.  Value: ${token} \
You'll find you API key at this location: https://app.bearer.sh/keys`);
    }
}
class InvalidRequestOptions extends Error {
    constructor() {
        super(`Unable to trigger API request. Request parameters should be an object \
in the form "{ headers: { "Foo": "bar" }, body: "My body" }"`);
    }
}
class MissingAuthId extends Error {
    constructor() {
        super('No authId has been set. Please call `auth`');
    }
}
/**
 * Exports
 */
exports.default = (apiKey, options) => {
    if (!apiKey) {
        throw new InvalidAPIKey(apiKey);
    }
    return new Bearer(apiKey, options);
};
