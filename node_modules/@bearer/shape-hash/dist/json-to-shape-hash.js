"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require('crypto');
function jsonToShapeHash(_data, options = { strict: false }) {
    const jsTypeString = Object.prototype.toString.call(_data);
    switch (jsTypeString) {
        case '[object Array]':
            return ShapeHash(1 /* ARRAY */, [], _data.map((item) => jsonToShapeHash(item, options)));
        case '[object Object]': {
            const data = options.strict
                ? _data
                : Object.keys(_data)
                    .sort()
                    .reduce(function (acc, key) {
                    acc[key] = _data[key];
                    return acc;
                }, {});
            return ShapeHash(0 /* OBJECT */, Object.entries(data).map(([key, value]) => ({ hash: jsonToShapeHash(value, options), key })), []);
        }
        case '[object Number]': {
            return ShapeHash(3 /* NUMBER */);
        }
        case '[object String]': {
            return ShapeHash(2 /* STRING */);
        }
        case '[object Null]': {
            return ShapeHash(5 /* NULL */);
        }
        case '[object Boolean]': {
            return ShapeHash(4 /* BOOLEAN */);
        }
        default:
            throw new Error('Unknown type! ' + jsTypeString);
    }
}
exports.jsonToShapeHash = jsonToShapeHash;
function toBytes(json, options = { strict: false }) {
    const hashMessage = jsonToShapeHash(json, options);
    return Buffer.from(JSON.stringify(hashMessage));
}
function toHash(json, options = { strict: false }) {
    return toBytes(json, options).toString('hex');
}
exports.toHash = toHash;
function toSha(json, options = { strict: false }) {
    const hash = crypto.createHash('sha256');
    hash.update(toBytes(json, options));
    return hash.digest('hex');
}
exports.toSha = toSha;
function ShapeHash(type, fields = [], items = [], rules = []) {
    return { fields, items, rules, type };
}
