"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.environmentName = exports.Configuration = exports.ConfigurationType = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const http_client_1 = require("./http-client");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const types_1 = require("./new-rules/types");
const delivery_1 = require("./report/delivery");
const syncEverySecs = 5;
const encodings = ['utf8', 'utf-8', 'ascii', 'binary', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'hex', 'base64'];
const debug = logger_1.logger.extend('config');
const OPTIONS = {
    configHost: {
        key: 'BEARER_AGENT_CONFIG_HOST',
        default: 'config.bearer.sh'
    },
    dataCollectionRules: {
        default: []
    },
    debugLevel: {
        key: 'BEARER_AGENT_DEBUG_LEVEL',
        default: 'info'
    },
    disabled: {
        key: 'BEARER_AGENT_DISABLED',
        default: false
    },
    environment: {
        key: 'BEARER_AGENT_ENV',
        default: process.env.NODE_ENV,
        formatter: environmentName
    },
    filtered: {
        key: 'BEARER_AGENT_FILTERED',
        formatter: commaSeparatedListToArray,
        default: []
    },
    filters: {
        default: {}
    },
    from: {
        key: 'BEARER_AGENT_CONFIG_FILE',
        default: undefined
    },
    generatedAt: {
        default: Date.now()
    },
    ignored: {
        key: 'BEARER_AGENT_IGNORE',
        formatter: commaSeparatedListToArray,
        default: []
    },
    logLevel: {
        key: 'BEARER_AGENT_LOG_LEVEL',
        choices: new Set([types_1.LogLevel.All, types_1.LogLevel.Restricted, types_1.LogLevel.Detected]),
        default: types_1.LogLevel.Detected
    },
    maximumBodySize: {
        key: 'BEARER_AGENT_MAXIMUM_BODY_SIZE',
        default: Math.pow(2, 20)
    },
    payloadTracking: {
        key: 'BEARER_AGENT_PAYLOAD_TRACKING_ENABLED',
        default: false,
        formatter: truthyValue
    },
    reportHost: {
        key: 'BEARER_AGENT_REPORT_HOST',
        default: 'agent.bearer.sh'
    },
    rules: {
        default: []
    },
    secretKey: {
        key: 'BEARER_SECRET_KEY',
        default: undefined
    },
    stripSensitiveData: {
        key: 'BEARER_AGENT_STRIP_SENSITIVE_DATA',
        formatter: truthyValue,
        default: 'true'
    },
    stripSensitiveRegex: {
        key: 'BEARER_AGENT_STRIP_SENSITIVE_REGEX',
        formatter: commaSeparatedToRegexp,
        default: [
            '[a-zA-Z0-9][a-zA-Z0-9.!#$%&â€™*+=?^_`{|}~-]{1,63}@[a-zA-Z0-9-]{1,256}(?:\\.[a-zA-Z0-9-]{1,256})*',
            '(?:\\d[ -]*?){13,16}'
        ]
    },
    stripSensitiveKeys: {
        key: 'BEARER_AGENT_STRIP_SENSITIVE_KEYS',
        formatter: commaSeparatedToRegexpInsensitive,
        default: [
            '^authorization$',
            '^password$',
            '^secret$',
            '^passwd$',
            '^api.?key$',
            '^access.?token$',
            '^auth.?token$',
            '^credentials$',
            '^mysql_pwd$',
            '^stripetoken$',
            '^card.?number.?$',
            '^secret$',
            '^client.?id$',
            '^client.?secret$'
        ].join(',')
    },
    throttleDisabled: {
        key: 'BEARER_AGENT_THROTTLE_DISABLED',
        formatter: falsyValue,
        default: 'false'
    }
};
const optionNames = Object.keys(OPTIONS);
class ConfigurationType {
    constructor() {
        this.nonRemoteOptions = {};
        this.options = {};
    }
    dump(params) {
        debug('dumping');
        const { filter = true } = params || {};
        const options = Object.assign({}, this.options);
        if (filter && options.secretKey) {
            options.secretKey = '******';
        }
        return options;
    }
    reset(options) {
        return __awaiter(this, void 0, void 0, function* () {
            debug('resetting');
            this.nonRemoteOptions = Object.assign(Object.assign(Object.assign({}, this.readFromEnv()), this.readFromConfigFile()), options);
            this.options = Object.assign({}, this.nonRemoteOptions);
            validateAppKey(this.options.secretKey || '');
            try {
                this.options = Object.assign(Object.assign({}, this.options), (yield this.readRemote()));
            }
            catch (e) {
                debug('remote config failed %s', e.toString());
            }
            debug('starting with current configuration: %j', this.options);
            this.startSync();
        });
    }
    readFromEnv() {
        return optionNames.reduce((acc, name) => {
            const { key, default: defaultValue, formatter } = OPTIONS[name];
            const value = (key && process.env[key]) || defaultValue;
            if (value) {
                acc[name] = formatter ? formatter(value) : value;
            }
            return acc;
        }, {});
    }
    readFromConfigFile() {
        const result = {};
        const configPath = configFilePath();
        if (configPath) {
            for (const encoding of encodings) {
                const config = tryReadConfigFile(configPath, encoding);
                for (const name of optionNames) {
                    const value = config[name];
                    if (value !== undefined) {
                        result[name] = value;
                    }
                }
            }
        }
        return result;
    }
    readRemote() {
        return __awaiter(this, void 0, void 0, function* () {
            const { configHost, secretKey } = this.nonRemoteOptions;
            if (!secretKey) {
                debug('no secret provided skipping data fetching');
                return {};
            }
            if (this.nonRemoteOptions.disabled) {
                debug('Skipping loading of remote configuration');
                return {};
            }
            const response = yield http_client_1.httpPost({
                hostname: configHost,
                path: '/config',
                headers: {
                    Accept: 'application/json',
                    Authorization: secretKey,
                    'Content-Type': 'application/json'
                },
                body: {
                    runtime: delivery_1.runtimeInfo,
                    agent: delivery_1.agentInfo,
                    application: {
                        environment: this.nonRemoteOptions.environment
                    }
                }
            });
            let parsedBody;
            try {
                parsedBody = JSON.parse(response.body);
            }
            catch (_a) { }
            if (response.statusCode != 200 || !parsedBody) {
                const error = parsedBody === null || parsedBody === void 0 ? void 0 : parsedBody.error;
                if (error) {
                    debug('error received: %j', error);
                    throw new errors_1.RemoteConfigError(response.statusCode, error.code, error.message);
                }
                debug('body received: %j', response.body);
                throw new errors_1.RemoteConfigError(response.statusCode, undefined, response.body);
            }
            const options = {};
            for (const name of optionNames) {
                const value = parsedBody[name];
                if (value !== undefined) {
                    options[name] = value;
                }
            }
            debug('remote config received: %j', options);
            return options;
        });
    }
    tryRefreshRemote() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.options = Object.assign(Object.assign(Object.assign({}, this.nonRemoteOptions), (yield this.readRemote())), { generatedAt: Date.now() });
            }
            catch (e) {
                debug('error while refreshing remote config');
            }
        });
    }
    startSync() {
        if (this.syncTimer) {
            clearTimeout(this.syncTimer);
        }
        const syncIteration = () => {
            this.syncTimer = setTimeout(body, syncEverySecs * 1000).unref();
        };
        const body = () => __awaiter(this, void 0, void 0, function* () {
            yield this.tryRefreshRemote();
            if (this.nonRemoteOptions.secretKey) {
                syncIteration();
            }
            else {
                this.syncTimer = undefined;
            }
        });
        syncIteration();
    }
}
exports.ConfigurationType = ConfigurationType;
exports.Configuration = new ConfigurationType();
for (const name of optionNames) {
    Object.defineProperty(exports.Configuration, name, {
        get: function () {
            return this.options[name];
        }
    });
}
/**
 * Helpers
 */
function tryReadConfigFile(path, encoding) {
    try {
        const config = fs_1.default.readFileSync(path, encoding);
        return JSON.parse(config);
    }
    catch (err) {
        // TODO: log error
        return {};
    }
}
function configFilePath() {
    const rootConfig = path_1.default.join(process.cwd(), 'bearer.json');
    if (fs_1.default.existsSync(rootConfig)) {
        return rootConfig;
    }
    const fromEnvPath = process.env['BEARER_AGENT_CONFIG_FILE'];
    if (fromEnvPath && fs_1.default.existsSync(fromEnvPath)) {
        return fromEnvPath;
    }
}
/**
 * Formatters
 */
const TRUTHY_VALUES = new Set(['1', 'true', 'yes']);
function truthyValue(value) {
    return TRUTHY_VALUES.has(value.toString().trim());
}
const FALSY_VALUES = new Set(['0', 'false', '', undefined]);
function falsyValue(value) {
    return !FALSY_VALUES.has(value.toString().trim());
}
function commaSeparatedListToArray(commaList) {
    if (typeof commaList === 'string') {
        return commaList.split(',').map(part => part.trim());
    }
    return commaList;
}
function commaSeparatedToRegexp(commaList, flag = 'g') {
    return new RegExp(commaSeparatedListToArray(commaList).join('|'), flag);
}
function commaSeparatedToRegexpInsensitive(commaList) {
    return commaSeparatedToRegexp(commaList, 'i');
}
function base64String(value) {
    return Buffer.from(value, 'utf8').toString('base64');
}
function environmentName(value) {
    if (value) {
        return base64String(value.toLowerCase());
    }
}
exports.environmentName = environmentName;
/**
 * Validators
 */
function validateAppKey(value) {
    if (value.startsWith('app_')) {
        debug('using environment %s (base64 encoded)', exports.Configuration.environment);
        return true;
    }
    console.warn('[BEARER] The bearer secret key provided looks incorrect, find your secret key at this location https://app.bearer.sh/keys');
    return true;
}
