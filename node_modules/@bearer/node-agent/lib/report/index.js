"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reporter = void 0;
const url_1 = __importDefault(require("url"));
const querystring_1 = __importDefault(require("querystring"));
const stage_1 = require("../stage");
const delivery_1 = require("./delivery");
const types_1 = require("../new-rules/types");
const errors_1 = require("../errors");
const logger_1 = require("../logger");
const headers_1 = require("../headers");
const sanitizer_1 = require("../sanitizer");
const shape_hash_1 = require("@bearer/shape-hash");
const debug = logger_1.logger.extend('reporter');
const PAYLOAD_HASH_NOT_APPLICABLE = 'N/A';
class Reporter {
    constructor(activeRules, globalSanitizerParams) {
        this.activeRules = activeRules;
        this.globalSanitizerParams = globalSanitizerParams;
        this.reported = false;
    }
    report(stage, remediationData) {
        this.ensureNotReported();
        const { error } = stage;
        const { logLevel, active } = this.activeRules;
        if (!active) {
            debug('deactivated api, skipping report');
            return;
        }
        const sanitizer = new sanitizer_1.Sanitizer(Object.assign(Object.assign({}, this.globalSanitizerParams), { ruleKeyPattern: this.activeRules.sanitizeKeyPattern, ruleValuePattern: this.activeRules.sanitizeValuePattern }));
        const connectionData = this.buildConnectionData(stage);
        // TODO: consider moving this after `logLevel === LogLevel.Detected` statement
        const requestData = this.buildRequestData(stage, sanitizer);
        const responseData = this.buildResponseData(stage, sanitizer);
        const bodiesData = this.buildBodiesData(stage, sanitizer);
        const { startedAt, endedAt, duration } = stage.timing;
        if (logLevel === types_1.LogLevel.Detected) {
            return delivery_1.enqueue(Object.assign(Object.assign({}, connectionData), { logLevel }));
        }
        const report = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, connectionData), requestData), requestData), responseData.data), bodiesData), { startedAt,
            logLevel,
            endedAt,
            remediationData, type: error ? delivery_1.ReportType.ConnectionError : delivery_1.ReportType.ApiCall, activeRules: getActiveRules(this.activeRules.activeRules), activeDataCollectionRules: getActiveDataCollectionRules(this.activeRules.activeDataCollectionRules), errorCode: error === null || error === void 0 ? void 0 : error.code, errorFullMessage: error === null || error === void 0 ? void 0 : error.stack, instrumentation: {
                requestBenchmark: duration,
                responseContentLength: responseData.contentLength
            }, stageType: stage === null || stage === void 0 ? void 0 : stage.typeName });
        delivery_1.enqueue(report);
    }
    buildConnectionData(stage) {
        const { connection: { protocol, hostname, port } } = stage;
        return {
            protocol,
            hostname,
            port
        };
    }
    buildRequestData(stage, sanitizer) {
        if (!stage.request) {
            return {};
        }
        const { connection, request } = stage;
        const { headers, method, path, id } = request;
        const fullData = this.activeRules.logLevel === types_1.LogLevel.All ? { requestHeaders: sanitizer.sanitize(headers) } : undefined;
        return Object.assign(Object.assign({}, fullData), { method, path: sanitizer.sanitize(path), url: buildUrl(connection, request, sanitizer), requestId: id });
    }
    buildResponseData(stage, sanitizer) {
        if (!stage.response) {
            return {};
        }
        const { response: { headers, status } } = stage;
        const fullData = this.activeRules.logLevel === types_1.LogLevel.All ? { responseHeaders: sanitizer.sanitize(headers) } : undefined;
        return {
            data: Object.assign(Object.assign({}, fullData), { statusCode: status }),
            contentLength: getContentLength(headers)
        };
    }
    buildBodiesData(stage, sanitizer) {
        if (!stage.bodies || this.activeRules.logLevel === types_1.LogLevel.Restricted) {
            return;
        }
        const { request, response } = stage.bodies;
        const { body: requestBody, hash: requestBodyPayloadSha } = buildBody(request, stage.request.headers, sanitizer);
        const { body: responseBody, hash: responseBodyPayloadSha } = buildBody(response, stage.response.headers, sanitizer);
        return { requestBody, requestBodyPayloadSha, responseBody, responseBodyPayloadSha };
    }
    ensureNotReported() {
        if (this.reported) {
            throw new errors_1.InternalError('Already reported this API call');
        }
        this.reported = true;
    }
}
exports.Reporter = Reporter;
const getActiveRules = (rules) => rules.map(({ id, filterHash, remediations }) => ({
    id,
    filterHash,
    remediationTypes: remediations.map(r => r.typeName)
}));
const getActiveDataCollectionRules = (rules) => rules.map(({ params, signature, filterHash }) => ({ params, signature, filterHash }));
const buildBody = (payload, headers, sanitizer) => {
    const contentType = headers_1.getHeaderValue(headers, 'Content-Type');
    if (!payload || payload === '' || !contentType) {
        return { body: payload, hash: PAYLOAD_HASH_NOT_APPLICABLE };
    }
    if (typeof payload !== 'string') {
        switch (true) {
            case /^application\/json/i.test(contentType):
                return {
                    body: JSON.stringify(sanitizer.sanitize(payload)),
                    hash: shape_hash_1.toSha(payload)
                };
            case /^application\/x-www-form-urlencoded/i.test(contentType):
                return {
                    body: querystring_1.default.stringify(sanitizer.sanitize(payload)),
                    hash: PAYLOAD_HASH_NOT_APPLICABLE
                };
        }
    }
    return { body: sanitizer.sanitize(payload), hash: PAYLOAD_HASH_NOT_APPLICABLE };
};
const getContentLength = (headers) => {
    const value = headers_1.getHeaderValue(headers, 'Content-Length');
    if (typeof value === 'number') {
        return value;
    }
    if (typeof value === 'string') {
        return parseInt(value, 10);
    }
};
const isDefaultPort = (port, protocol) => {
    switch (protocol) {
        case stage_1.Protocol.Http:
            return port === 80;
        case stage_1.Protocol.Https:
            return port === 443;
        default:
            throw new errors_1.InternalError(`Unexpected protocol '${protocol}'`);
    }
};
const buildUrl = ({ hostname, port, protocol }, { path, params }, sanitizer) => {
    const portUnlessDefault = isDefaultPort(port, protocol) ? undefined : port;
    return url_1.default.format({
        hostname,
        protocol,
        pathname: sanitizer.sanitizeUrlPath(path),
        port: portUnlessDefault,
        query: sanitizer.sanitize(params)
    });
};
