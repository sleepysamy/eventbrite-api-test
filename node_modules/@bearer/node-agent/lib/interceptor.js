"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isURL = exports.extractRequest = exports.intercept = void 0;
const url_1 = require("url");
const http_1 = __importStar(require("http"));
const querystring_1 = __importDefault(require("querystring"));
const uuid_1 = require("uuid");
const config_1 = require("./config");
const report_1 = require("./report");
const hook_method_1 = require("./hook-method");
const errors_1 = require("./errors");
const retry_1 = require("./retry");
const logger_1 = require("./logger");
const stage_1 = require("./stage");
const new_rules_1 = require("./new-rules");
const filters_1 = require("./new-rules/filters");
const types_1 = require("./new-rules/types");
const stream_1 = require("stream");
const debug = logger_1.logger.extend('interceptor');
exports.intercept = (module) => {
    const originalRequest = module.request;
    const request = function (urlOrOptions, optionsOrCallback, callback) {
        if (config_1.Configuration.disabled) {
            return originalRequest.apply(this, arguments);
        }
        try {
            const extractedRequest = extractRequest(module === http_1.default, urlOrOptions, optionsOrCallback);
            const { options, parsedQuery } = extractedRequest;
            const { hostname } = options;
            if (!trackableUrl(hostname)) {
                debug('ignoring: %s', extractedRequest.url);
                return originalRequest.apply(this, arguments);
            }
            debug('processing request: %j', extractedRequest);
            const connectionData = {
                hostname: hostname,
                port: options.port || (module === http_1.default ? 80 : 443),
                protocol: options.protocol.replace(/:$/, '')
            };
            const { stageManager, ruleManager } = newConnection(connectionData);
            /**
             * Where magic happen for blocked requests.
             * We provide createConnection option so that we do not even try to connect to the distant api.
             * At the same time, it gives us a better control over emitted events
             */
            const requestData = {
                method: options.method.toUpperCase(),
                headers: options.headers,
                params: parsedQuery,
                path: options.path,
                id: uuid_1.v4()
            };
            stageManager.request(requestData);
            if (!ruleManager.active) {
                debug('api deactivated, skipping monitoring');
                return originalRequest.apply(this, arguments);
            }
            if (ruleManager.blockRemediation) {
                debug('blocking rule found: %j', ruleManager.blockRemediation);
                const { error, req } = blockedClientRequest();
                stageManager.blockRemediation();
                stageManager.connectionError(error);
                return req;
            }
            let lastRetryRemediation;
            const req = originalRequest.apply(this, arguments);
            applyTimeout({ req, ruleManager, stageManager, hostname });
            const requestBodyChunks = [];
            let reqEnded = false; // has the user called req.end() yet?
            const isVerbose = ruleManager.logLevel === types_1.LogLevel.All;
            const isParsableRequestBody = isParsableBody(options.headers);
            let retryListenerMover = new retry_1.RetryListenerMover();
            let retryProxyHookAction;
            const retry = new retry_1.Retry(() => {
                const { stageManager, ruleManager } = newConnection(connectionData);
                stageManager.request(requestData);
                const retryReq = originalRequest.call(module, options);
                applyTimeout({ ruleManager, stageManager, hostname, req: retryReq });
                retryProxyHookAction = new hook_method_1.ProxyHookAction(retryReq);
                hookEmit(retryReq, stageManager, ruleManager);
                retryReq._redirectable = req._redirectable;
                retryListenerMover.popListeners(retryReq);
                // Send all the data that has been written to prior requests
                for (const chunk of requestBodyChunks) {
                    retryReq.write(chunk);
                }
                if (reqEnded) {
                    retryReq.end();
                }
            });
            /**
             * Override write method to capture the body sent`
             */
            hook_method_1.hookMethod(req, 'write', (chunk, encodingOrCallback) => {
                if (chunk) {
                    const encoding = typeof encodingOrCallback === 'string' ? encodingOrCallback : undefined;
                    requestBodyChunks.push(dataToChunk(chunk, encoding));
                }
                return retryProxyHookAction;
            });
            hook_method_1.hookMethod(req, 'end', (chunkOrCallback, encodingOrCallback) => {
                reqEnded = true;
                const chunk = chunkOrCallback && typeof chunkOrCallback !== 'function' ? chunkOrCallback : undefined;
                if (chunk) {
                    const encoding = typeof encodingOrCallback === 'string' ? encodingOrCallback : undefined;
                    requestBodyChunks.push(dataToChunk(chunk, encoding));
                }
                return retryProxyHookAction;
            });
            hook_method_1.hookMethod(req, 'abort', () => {
                debug('adding abort hooks');
                return retryProxyHookAction;
            });
            const hookEmit = (requestInstance, stageManager, ruleManager) => {
                hook_method_1.hookMethod(requestInstance, 'emit', function (eventName, data) {
                    debug('event received: %s', eventName);
                    switch (eventName) {
                        case 'response': {
                            const res = data;
                            const isParsableResponseBody = isParsableBody(res.headers);
                            const captureResponse = isParsableResponseBody && isVerbose;
                            stageManager.response({
                                status: res.statusCode,
                                headers: res.headers
                            });
                            const responseBodyChunks = [];
                            const pass = new stream_1.PassThrough();
                            pass.on('end', () => {
                                stageManager.bodies({
                                    request: chunksToBody(isVerbose, isParsableRequestBody, requestBodyChunks),
                                    response: chunksToBody(isVerbose, isParsableResponseBody, responseBodyChunks)
                                });
                                stageManager.report();
                            });
                            let piped = false;
                            const _pipe = res.pipe;
                            function bearerPipe() {
                                if (!piped) {
                                    piped = true;
                                    _pipe.apply(res, [pass]);
                                }
                            }
                            // if pipe is used we must wait before register otherwise stream will get consumed
                            // before the pipe is registered leading to incomplete chunks received
                            hook_method_1.hookMethod(res, 'pipe', () => {
                                bearerPipe();
                            });
                            // rather than attaching stream too early, we wait for everyone to have registered
                            hook_method_1.hookMethod(res, 'on', () => {
                                bearerPipe();
                            });
                            if (captureResponse) {
                                pass.on('data', chunk => {
                                    // TODO: don't assume utf8 for strings
                                    responseBodyChunks.push(dataToChunk(chunk, undefined));
                                });
                            }
                            else {
                                // we do not capture any data, required to go to the bodies stage
                                pass.resume();
                            }
                            const attempt = retry.attempt;
                            if (retry.retry(ruleManager.retryRemediation)) {
                                lastRetryRemediation = ruleManager.retryRemediation || lastRetryRemediation;
                                retryListenerMover.pushListeners(this);
                                // There must be at least one response handler otherwise none of the
                                // response events (ie. data, end) are triggered
                                this.on('response', () => { });
                                // If we didn't attach the data handler then we need to consume the stream
                                if (!captureResponse) {
                                    debug('resuming request');
                                    res.resume();
                                }
                            }
                            stageManager.retryRemediation(lastRetryRemediation, attempt);
                            break;
                        }
                        case 'error': {
                            const error = data;
                            stageManager.connectionError(error);
                            const attempt = retry.attempt;
                            if (retry.retry(ruleManager.retryRemediation)) {
                                lastRetryRemediation = ruleManager.retryRemediation || lastRetryRemediation;
                                retryListenerMover.pushListeners(this);
                                // There must be at least one error handler to suppress default error handling
                                this.on('error', () => { });
                            }
                            stageManager.retryRemediation(lastRetryRemediation, attempt);
                            stageManager.report();
                            break;
                        }
                        case 'abort': {
                            // TODO: report aborted request
                            break;
                        }
                    }
                });
            };
            hookEmit(req, stageManager, ruleManager);
            return req;
        }
        catch (e) {
            debug('error while executing : %j', e.toString());
            return originalRequest.apply(this, arguments);
        }
    };
    // })
    module.request = request;
    // Simple enough to be overridden that way
    module.get = function (url, options, cb) {
        const req = module.request.apply(this, arguments);
        req.end();
        return req;
    };
    return originalRequest;
};
const newConnection = (connection) => {
    const filterEvaluator = new filters_1.FilterEvaluator(config_1.Configuration.filters);
    const ruleManager = new new_rules_1.RuleManager(filterEvaluator, config_1.Configuration.rules, config_1.Configuration.dataCollectionRules);
    const reporter = new report_1.Reporter(ruleManager, {
        globalKeyPattern: config_1.Configuration.stripSensitiveKeys,
        globalValuePattern: config_1.Configuration.stripSensitiveData ? config_1.Configuration.stripSensitiveRegex : undefined,
        filtered: config_1.Configuration.filtered
    });
    const stageManager = new stage_1.StageManager(ruleManager, reporter, config_1.Configuration.maximumBodySize);
    stageManager.connect(connection);
    return { stageManager, ruleManager };
};
const applyTimeout = ({ req, ruleManager, stageManager, hostname }) => {
    if (ruleManager.timeoutRemediation) {
        debug('timeout rule found: %j', ruleManager.timeoutRemediation);
        stageManager.timeoutRemediation(ruleManager.timeoutRemediation);
        const { duration } = ruleManager.timeoutRemediation;
        req.setTimeout(duration, () => {
            req.emit('error', new errors_1.RequestTimeout(duration, hostname));
            req.abort();
        });
    }
};
function extractRequest(isHttp, urlOrOptions, optionsOrCallback) {
    let options;
    if (typeof urlOrOptions === 'string') {
        options = url_1.parse(urlOrOptions);
    }
    else if (isURL(urlOrOptions)) {
        // URL object
        options = {
            protocol: urlOrOptions.protocol,
            hostname: urlOrOptions.hostname,
            port: urlOrOptions.port,
            query: urlOrOptions.search,
            path: urlOrOptions.pathname
        };
    }
    else {
        options = Object.assign({}, urlOrOptions);
    }
    if (typeof optionsOrCallback === 'object') {
        options = Object.assign(Object.assign({}, options), optionsOrCallback);
    }
    const query = options.search || '';
    const protocol = options.protocol || (isHttp ? 'http:' : 'https:');
    const hostname = options.hostname || options.host || 'localhost';
    const port = options.port;
    const pathname = options.pathname || options.path || '/';
    const headers = options.headers || {};
    const method = options.method || 'GET';
    return {
        options: {
            protocol,
            hostname,
            port,
            query,
            headers,
            method,
            path: pathname
        },
        parsedQuery: querystring_1.default.parse(query.replace(/^\?/, ''))
    };
}
exports.extractRequest = extractRequest;
function trackableUrl(domain) {
    if (config_1.Configuration.ignored.some((ignored) => ignored.includes(domain))) {
        return false;
    }
    return true;
}
const CONTENT_TYPE = /^Content-Type$/i;
const PARSABLE_CONTENT_TYPE = /json|text|xml|x-www-form-urlencoded/i;
/**
 * headers Helpers
 */
function isParsableBody(headers) {
    return Object.keys(headers).some(headerName => CONTENT_TYPE.test(headerName) && PARSABLE_CONTENT_TYPE.test(headers[headerName]));
}
function dataToChunk(data, encoding) {
    return typeof data === 'string' ? Buffer.from(data, encoding) : data;
}
function chunksToBody(isVerbose, isParsable, chunks) {
    if (!isVerbose || !isParsable) {
        return Buffer.alloc(0);
    }
    return Buffer.concat(chunks);
}
const blockedClientRequest = () => {
    const req = new http_1.OutgoingMessage();
    Object.setPrototypeOf(req, http_1.ClientRequest.prototype);
    const error = new errors_1.RequestBlocked();
    setImmediate(() => req.emit('error', error));
    return { error, req };
};
function isURL(anUrl) {
    return anUrl instanceof url_1.URL;
}
exports.isURL = isURL;
