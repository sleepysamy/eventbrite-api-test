import { Filter, KeyValueFilterBase, Range } from './types';
import { Stage } from '../stage';
/**
 * The FilterEvaluator evaluates `Filter`s using the state from a Stage.
 *
 * Filter evaluations that are known are cached
 */
export declare class FilterEvaluator {
    private filters;
    private cache;
    constructor(filters: Record<string, Filter>);
    eval(hash: string, stage: Stage, parentHashes?: string[]): FilterResult;
    private evalFilter;
    private matchValue;
    /**
     * Filter eval functions
     */
    private evalNotFilter;
    private evalFilterSet;
    private evalDomainFilter;
    private evalRequestMethodFilter;
    private evalRequestParamFilter;
    private evalRequestPathFilter;
    private evalRequestHeaderFilter;
    private evalResponseHeaderFilter;
    private evalResponseStatusFilter;
    private evalRequestBodyFilter;
    private evalRequestBodySizeFilter;
    private evalResponseBodyFilter;
    private evalResponseBodySizeFilter;
    private evalConnectionErrorFilter;
    private evalDurationFilter;
    private evalFunctions;
}
export declare const matchRange: (range: Range, value?: number | undefined) => FilterResult.Match | FilterResult.NoMatch;
export declare const matchKeyValue: ({ keyPattern, valuePattern }: KeyValueFilterBase, value?: any) => FilterResult.Match | FilterResult.NoMatch;
export declare enum FilterResult {
    Match = "match",
    NoMatch = "no_match",
    Unknown = "unknown"
}
