"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleManager = void 0;
const types_1 = require("./types");
const filters_1 = require("./filters");
const config_1 = require("../config");
/**
 * The RuleManager evaluates the filters for each rule using the state from a
 * Stage. It maintains a list of active rules, data collection rules, and
 * remediations.
 */
class RuleManager {
    constructor(filterEvaluator, rules, dataCollectionRules) {
        this.filterEvaluator = filterEvaluator;
        this.rules = rules;
        this.dataCollectionRules = dataCollectionRules;
        this.activeRules = [];
        this.activeDataCollectionRules = [];
        this.config = {};
    }
    evaluateRules(stage) {
        if (stage.typeName === types_1.StageType.Bodies) {
            // Bodies rules are not yet supported
            return;
        }
        this.activeRules = this.getActiveRules(stage, this.rules);
        this.activeDataCollectionRules = this.getActiveRules(stage, this.dataCollectionRules);
        this.blockRemediation = this.getRemediation(types_1.RemediationType.BlockRequest);
        this.retryRemediation = this.getRemediation(types_1.RemediationType.Retry);
        this.timeoutRemediation = this.getRemediation(types_1.RemediationType.Timeout);
        this.config = this.getConfig();
    }
    get logLevel() {
        return this.config.logLevel || config_1.Configuration.logLevel;
    }
    get sanitizeKeyPattern() {
        if (this.config.sanitizeKeyPattern) {
            return new RegExp(this.config.sanitizeKeyPattern.value, this.config.sanitizeKeyPattern.flags);
        }
    }
    get sanitizeValuePattern() {
        if (this.config.sanitizeValuePattern) {
            return new RegExp(this.config.sanitizeValuePattern.value, this.config.sanitizeValuePattern.flags);
        }
    }
    get active() {
        if (this.config.active !== undefined) {
            return this.config.active;
        }
        return !config_1.Configuration.disabled;
    }
    getConfig() {
        let result = {};
        for (const rule of this.activeDataCollectionRules) {
            Object.assign(result, rule.config);
        }
        return result;
    }
    getActiveRules(stage, rules) {
        return rules.filter(rule => {
            if (rule.expiresIn && rule.expiresIn < Date.now() - config_1.Configuration.generatedAt) {
                return false;
            }
            else if (!rule.filterHash) {
                return true;
            }
            else if (this.filterEvaluator.eval(rule.filterHash, stage) === filters_1.FilterResult.Match) {
                return true;
            }
            else {
                return false;
            }
        });
    }
    getRemediation(type) {
        for (const rule of this.activeRules) {
            const remediation = rule.remediations.find(r => r.typeName === type);
            if (remediation) {
                return remediation;
            }
        }
    }
}
exports.RuleManager = RuleManager;
