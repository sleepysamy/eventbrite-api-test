"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterResult = exports.matchKeyValue = exports.matchRange = exports.FilterEvaluator = void 0;
const types_1 = require("./types");
const errors_1 = require("../errors");
const logger_1 = require("../logger");
const debug = logger_1.logger.extend('filters');
/**
 * The FilterEvaluator evaluates `Filter`s using the state from a Stage.
 *
 * Filter evaluations that are known are cached
 */
class FilterEvaluator {
    constructor(filters) {
        this.filters = filters;
        this.cache = {};
        /**
         * Filter eval functions
         */
        this.evalNotFilter = (filter, stage, parentHashes) => {
            const childResult = this.eval(filter.childHash, stage, parentHashes);
            switch (childResult) {
                case FilterResult.Match:
                    return FilterResult.NoMatch;
                case FilterResult.NoMatch:
                    return FilterResult.Match;
                case FilterResult.Unknown:
                    return FilterResult.Unknown;
            }
        };
        this.evalFilterSet = ({ childHashes, operator }, stage, parentHashes) => {
            const childResults = childHashes.map(hash => this.eval(hash, stage, parentHashes));
            switch (operator) {
                case types_1.FilterSetOperator.All:
                    if (childResults.every(r => r === FilterResult.Match)) {
                        return FilterResult.Match;
                    }
                    break;
                case types_1.FilterSetOperator.Any:
                    if (childResults.some(r => r === FilterResult.Match)) {
                        return FilterResult.Match;
                    }
                    break;
                default:
                    throw new Error(`Unexpected filter set operator '${operator}'`);
            }
            if (childResults.some(r => r === FilterResult.Unknown)) {
                return FilterResult.Unknown;
            }
            return FilterResult.NoMatch;
        };
        this.evalDomainFilter = (filter, stage) => {
            if (!stage.connection) {
                return FilterResult.Unknown;
            }
            return boolToFilterResult(this.matchValue(filter.pattern, stage.connection.hostname));
        };
        this.evalRequestMethodFilter = (filter, stage) => {
            if (!stage.request) {
                return FilterResult.Unknown;
            }
            return boolToFilterResult(stage.request.method === filter.value);
        };
        this.evalRequestParamFilter = (filter, stage) => {
            if (!stage.request) {
                return FilterResult.Unknown;
            }
            return exports.matchKeyValue(filter, stage.request.params);
        };
        this.evalRequestPathFilter = (filter, stage) => {
            if (!stage.request) {
                return FilterResult.Unknown;
            }
            return boolToFilterResult(this.matchValue(filter.pattern, stage.request.path));
        };
        this.evalRequestHeaderFilter = (filter, stage) => {
            if (!stage.request) {
                return FilterResult.Unknown;
            }
            return exports.matchKeyValue(filter, stage.request.headers);
        };
        this.evalResponseHeaderFilter = (filter, stage) => {
            if (!stage.response) {
                return FilterResult.Unknown;
            }
            return exports.matchKeyValue(filter, stage.response.headers);
        };
        this.evalResponseStatusFilter = (filter, stage) => {
            if (!stage.response) {
                return FilterResult.Unknown;
            }
            return exports.matchRange(filter.range, stage.response.status);
        };
        this.evalRequestBodyFilter = (filter, stage) => {
            if (!stage.bodies) {
                return FilterResult.Unknown;
            }
            return exports.matchKeyValue(filter, stage.bodies.request);
        };
        this.evalRequestBodySizeFilter = (filter, stage) => {
            if (!stage.bodies) {
                return FilterResult.Unknown;
            }
            return exports.matchRange(filter.range, stage.bodies.requestSize);
        };
        this.evalResponseBodyFilter = (filter, stage) => {
            if (!stage.bodies) {
                return FilterResult.Unknown;
            }
            return exports.matchKeyValue(filter, stage.bodies.response);
        };
        this.evalResponseBodySizeFilter = (filter, stage) => {
            if (!stage.bodies) {
                return FilterResult.Unknown;
            }
            return exports.matchRange(filter.range, stage.bodies.responseSize);
        };
        this.evalConnectionErrorFilter = (_filter, stage) => {
            if (!stage.error) {
                return FilterResult.Unknown;
            }
            // Don't treat Bearer errors as connection errors
            return boolToFilterResult(!(stage.error instanceof errors_1.CustomError));
        };
        this.evalDurationFilter = (filter, stage) => {
            if (!stage.timing) {
                return FilterResult.Unknown;
            }
            return exports.matchRange(filter.range, stage.timing.duration);
        };
        this.evalFunctions = {
            // WARNING: All functions used here must be arrow functions
            // Structural
            [types_1.FilterType.FilterSet]: this.evalFilterSet,
            [types_1.FilterType.Not]: this.evalNotFilter,
            // Connect
            [types_1.FilterType.Domain]: this.evalDomainFilter,
            // Request
            [types_1.FilterType.HttpMethod]: this.evalRequestMethodFilter,
            [types_1.FilterType.Param]: this.evalRequestParamFilter,
            [types_1.FilterType.Path]: this.evalRequestPathFilter,
            [types_1.FilterType.RequestHeader]: this.evalRequestHeaderFilter,
            // Response
            [types_1.FilterType.ResponseHeader]: this.evalResponseHeaderFilter,
            [types_1.FilterType.StatusCode]: this.evalResponseStatusFilter,
            // Bodies
            [types_1.FilterType.RequestBody]: this.evalRequestBodyFilter,
            [types_1.FilterType.RequestBodySize]: this.evalRequestBodySizeFilter,
            [types_1.FilterType.ResponseBody]: this.evalResponseBodyFilter,
            [types_1.FilterType.ResponseBodySize]: this.evalResponseBodySizeFilter,
            // ConnectionError
            [types_1.FilterType.ConnectionError]: this.evalConnectionErrorFilter,
            // Bodies/Error
            [types_1.FilterType.Duration]: this.evalDurationFilter
        };
    }
    // parentHashes is used internally for detecting infinite recursion
    eval(hash, stage, parentHashes = []) {
        if (this.cache[hash] !== undefined) {
            return this.cache[hash];
        }
        if (parentHashes.includes(hash)) {
            throw new errors_1.InternalError(`Loop detected in filter '${hash}'`);
        }
        const filter = this.filters[hash];
        if (!filter) {
            throw new errors_1.InternalError(`No filter exists with hash '${hash}'`);
        }
        const result = this.evalFilter(filter, stage, parentHashes.concat(hash));
        if (result !== FilterResult.Unknown) {
            this.cache[hash] = result;
        }
        debug("Evaluated filter '%s', result '%s'", hash, result);
        return result;
    }
    evalFilter(filter, stage, parentHashes) {
        const doEval = this.evalFunctions[filter.typeName];
        if (!doEval) {
            debug(`Unexpected filter type '${filter.typeName}`);
            // Return unknown so it doesn't effect structural filters (eg. NOT)
            return FilterResult.Unknown;
        }
        return doEval(filter, stage, parentHashes);
    }
    matchValue(pattern, value) {
        const regex = regexForPattern(pattern);
        const match = (value) => {
            if (value === undefined) {
                return false;
            }
            if (Array.isArray(value)) {
                return value.some(match);
            }
            return regex.test(value.toString());
        };
        return match(value);
    }
}
exports.FilterEvaluator = FilterEvaluator;
const boolToFilterResult = (value) => (value ? FilterResult.Match : FilterResult.NoMatch);
exports.matchRange = (range, value) => {
    if (value === undefined) {
        return FilterResult.NoMatch;
    }
    const { from, fromExclusive, to, toExclusive } = range;
    const fromMatch = from === undefined || (fromExclusive && value > from) || (!fromExclusive && value >= from);
    const toMatch = to === undefined || (toExclusive && value < to) || (!toExclusive && value <= to);
    return boolToFilterResult(fromMatch && toMatch);
};
exports.matchKeyValue = ({ keyPattern, valuePattern }, value) => {
    if (value === undefined) {
        return FilterResult.NoMatch;
    }
    if (!keyPattern && !valuePattern) {
        return FilterResult.Match;
    }
    const keyRegex = regexForPattern(keyPattern);
    const valueRegex = regexForPattern(valuePattern);
    const match = (data) => {
        switch (true) {
            case data === undefined || data === null:
                return false;
            case typeof data === 'string':
                return !keyRegex && valueRegex.test(data);
            case typeof data === 'number':
                return false;
            case Array.isArray(data):
                return data.some(element => match(element));
            default:
                return Object.entries(data).some(([key, subValue]) => {
                    if (typeof subValue === 'string') {
                        return (!keyRegex || keyRegex.test(key)) && (!valueRegex || valueRegex.test(subValue));
                    }
                    else {
                        return match(subValue);
                    }
                });
        }
    };
    return boolToFilterResult(match(value));
};
const regexForPattern = (pattern) => pattern && new RegExp(pattern.value, pattern.flags);
var FilterResult;
(function (FilterResult) {
    // call stage >= filter stage and the filter matches
    FilterResult["Match"] = "match";
    // call stage >= filter stage and the filter does NOT match
    FilterResult["NoMatch"] = "no_match";
    // Either:
    //   - call stage < filter stage so we don't yet know if the filter will match
    //   - or, the filter type is unsupported
    FilterResult["Unknown"] = "unknown";
})(FilterResult = exports.FilterResult || (exports.FilterResult = {}));
