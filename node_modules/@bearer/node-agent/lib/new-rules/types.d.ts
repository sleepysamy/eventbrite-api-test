export declare enum StageType {
    Connect = "ConnectStage",
    Request = "RequestStage",
    Response = "ResponseStage",
    Bodies = "BodiesStage"
}
export declare enum FilterType {
    Not = "NotFilter",
    FilterSet = "FilterSet",
    Domain = "DomainFilter",
    HttpMethod = "HttpMethodFilter",
    Path = "PathFilter",
    Param = "ParamFilter",
    RequestHeader = "RequestHeaderFilter",
    ResponseHeader = "ResponseHeaderFilter",
    StatusCode = "StatusCodeFilter",
    RequestBody = "RequestBodyFilter",
    RequestBodySize = "RequestBodySizeFilter",
    ResponseBody = "ResponseBodyFilter",
    ResponseBodySize = "ResponseBodySizeFilter",
    ConnectionError = "ConnectionErrorFilter",
    Duration = "DurationFilter"
}
export declare enum HttpMethod {
    Get = "GET",
    Post = "POST",
    Patch = "PATCH",
    Put = "PUT",
    Delete = "DELETE",
    Head = "HEAD",
    Options = "OPTIONS"
}
export interface Range {
    from?: number;
    fromExclusive?: boolean;
    to?: number;
    toExclusive?: boolean;
}
export interface RegularExpression {
    value: string;
    flags?: string;
}
export declare enum FilterSetOperator {
    All = "ALL",
    Any = "ANY"
}
export interface HttpMethodFilter {
    typeName: FilterType.HttpMethod;
    value: HttpMethod;
}
export interface DomainFilter {
    typeName: FilterType.Domain;
    pattern: RegularExpression;
}
export interface RangeFilterBase {
    range: Range;
}
export interface StatusCodeFilter extends RangeFilterBase {
    typeName: FilterType.StatusCode;
}
export interface PathFilter {
    typeName: FilterType.Path;
    pattern: RegularExpression;
}
export interface KeyValueFilterBase {
    valuePattern?: RegularExpression;
    keyPattern?: RegularExpression;
}
export interface ParamFilter extends KeyValueFilterBase {
    typeName: FilterType.Param;
}
export interface RequestHeaderFilter extends KeyValueFilterBase {
    typeName: FilterType.RequestHeader;
}
export interface ResponseHeaderFilter extends KeyValueFilterBase {
    typeName: FilterType.ResponseHeader;
}
export interface RequestBodyFilter extends KeyValueFilterBase {
    typeName: FilterType.RequestBody;
}
export interface RequestBodySizeFilter extends RangeFilterBase {
    typeName: FilterType.RequestBodySize;
}
export interface ResponseBodyFilter extends KeyValueFilterBase {
    typeName: FilterType.ResponseBody;
}
export interface ResponseBodySizeFilter extends RangeFilterBase {
    typeName: FilterType.ResponseBodySize;
}
export interface DurationFilter extends RangeFilterBase {
    typeName: FilterType.Duration;
}
export interface NotFilter {
    typeName: FilterType.Not;
    childHash: string;
}
export interface ConnectionErrorFilter {
    typeName: FilterType.ConnectionError;
}
export interface FilterSet {
    typeName: FilterType.FilterSet;
    operator: FilterSetOperator;
    childHashes: string[];
}
export declare type StructuralFilter = FilterSet | NotFilter;
export declare type ConnectionFilter = DomainFilter;
export declare type RequestFilter = HttpMethodFilter | PathFilter | ParamFilter | RequestHeaderFilter;
export declare type ResponseFilter = ResponseHeaderFilter | StatusCodeFilter;
export declare type BodiesFilter = RequestBodyFilter | RequestBodySizeFilter | ResponseBodyFilter | ResponseBodySizeFilter;
export declare type Filter = StructuralFilter | ConnectionFilter | RequestFilter | ResponseFilter | BodiesFilter | ConnectionErrorFilter | DurationFilter;
export declare enum RemediationType {
    BlockRequest = "BlockRequest",
    Timeout = "TimeoutRemediation",
    Retry = "RetryRemediation"
}
export declare type BlockRequestRemediation = {
    typeName: RemediationType.BlockRequest;
};
export declare type TimeoutRemediation = {
    typeName: RemediationType.Timeout;
    duration: number;
};
export declare enum RetryType {
    Exponential = "EXPONENTIAL",
    Uniform = "UNIFORM"
}
export declare type RetryRemediation = {
    typeName: RemediationType.Retry;
    retryType: RetryType;
    attempts: number;
    delay: number;
};
export declare type Remediation = BlockRequestRemediation | TimeoutRemediation | RetryRemediation;
export interface Rule {
    id: string;
    filterHash?: string;
    remediations: Remediation[];
    expiresIn?: number;
}
export interface DataCollectionRule {
    filterHash?: string;
    params: any;
    config?: DynamicConfig;
    signature: string;
}
export interface DynamicConfig {
    logLevel?: LogLevel;
    active?: boolean;
    sanitizeKeyPattern?: RegularExpression;
    sanitizeValuePattern?: RegularExpression;
}
export declare enum LogLevel {
    All = "ALL",
    Restricted = "RESTRICTED",
    Detected = "DETECTED"
}
