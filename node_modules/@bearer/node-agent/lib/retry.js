"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryListenerMover = exports.exponentialBackoffMs = exports.Retry = void 0;
const types_1 = require("./new-rules/types");
const logger_1 = require("./logger");
const debug = logger_1.logger.extend('retry');
class Retry {
    constructor(performRetry) {
        this.performRetry = performRetry;
        this.attempt = 1;
    }
    retry(remediation) {
        if (!remediation || this.attempt > remediation.attempts) {
            return false;
        }
        const backoffMs = this.backoffMs(remediation);
        debug('performing retry: attempt: %d/%d backoffMs: %d', this.attempt, remediation.attempts, backoffMs);
        setTimeout(() => this.performRetry(), backoffMs);
        this.attempt += 1;
        return true;
    }
    backoffMs({ delay, retryType }) {
        if (retryType === types_1.RetryType.Uniform) {
            return delay;
        }
        return exports.exponentialBackoffMs({ delay, attempt: this.attempt });
    }
}
exports.Retry = Retry;
exports.exponentialBackoffMs = ({ delay, attempt }) => {
    return delay * Math.pow(2, (attempt - 2));
};
const movableEvents = ['abort', 'connect', 'continue', 'error', 'information', 'response', 'timeout', 'upgrade'];
// This is used to remove the event types listed above from the current (failed) request
// and re-add them to the new (retried) request. Because the failure and the creation of
// the new request happen at different times, we must do this in two separate steps.
class RetryListenerMover {
    constructor() {
        this.listeners = {};
    }
    pushListeners(req) {
        for (const name of movableEvents) {
            const eventListeners = (this.listeners[name] = { once: [], on: [] });
            for (const rawListener of [...req.rawListeners(name)]) {
                let listener;
                if (rawListener.listener) {
                    listener = rawListener.listener;
                    eventListeners.once.push(listener);
                }
                else {
                    listener = rawListener;
                    eventListeners.on.push(listener);
                }
                req.removeListener(name, listener);
            }
        }
    }
    popListeners(req) {
        for (const name of movableEvents) {
            const eventListeners = this.listeners[name];
            for (const onceListener of eventListeners.once) {
                req.once(name, onceListener);
            }
            for (const onListener of eventListeners.on) {
                req.on(name, onListener);
            }
        }
    }
}
exports.RetryListenerMover = RetryListenerMover;
