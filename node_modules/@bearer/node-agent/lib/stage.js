"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Protocol = exports.StageManager = void 0;
const errors_1 = require("./errors");
const types_1 = require("./new-rules/types");
const logger_1 = require("./logger");
const body_1 = require("./body");
const headers_1 = require("./headers");
const debug = logger_1.logger.extend('stage');
/**
 * The StageManager keeps track of where we are in the process of an API call
 * and invokes appropriate actions at each stage.
 */
class StageManager {
    constructor(ruleActions, reportActions, maxBodySize) {
        this.ruleActions = ruleActions;
        this.reportActions = reportActions;
        this.maxBodySize = maxBodySize;
        this.remediationData = {};
    }
    connect(connection) {
        this.expectStage(undefined);
        this.startedAt = Date.now();
        this.stage = {
            typeName: types_1.StageType.Connect,
            connection
        };
        debug('Moving to stage', this.stage.typeName);
        this.ruleActions.evaluateRules(this.stage);
    }
    request(request) {
        this.expectStage(types_1.StageType.Connect);
        this.stage = Object.assign(Object.assign({}, this.stage), { typeName: types_1.StageType.Request, request });
        debug('Moving to stage', this.stage.typeName);
        this.ruleActions.evaluateRules(this.stage);
    }
    response(response) {
        this.expectStage(types_1.StageType.Request);
        this.stage = Object.assign(Object.assign({}, this.stage), { typeName: types_1.StageType.Response, response });
        debug('Moving to stage', this.stage.typeName);
        this.ruleActions.evaluateRules(this.stage);
    }
    bodies({ request, response }) {
        this.expectStage(types_1.StageType.Response);
        const { value: requestBody, size: requestBodySize } = this.parseBody(request, this.stage.request.headers);
        const { value: responseBody, size: responseBodySize } = this.parseBody(response, this.stage.response.headers);
        this.stage = Object.assign(Object.assign({}, this.stage), { bodies: {
                requestSize: requestBodySize,
                responseSize: responseBodySize,
                request: requestBody,
                response: responseBody
            }, timing: this.getTiming(), typeName: types_1.StageType.Bodies });
        debug('Moving to stage', this.stage.typeName);
        this.ruleActions.evaluateRules(this.stage);
    }
    connectionError(error) {
        if (!this.stage) {
            throw new errors_1.InternalError(`Error during initialisation:\n${error}`);
        }
        if (this.stage.error) {
            throw new errors_1.InternalError(`Error after error already reported. New error:\n${error}`);
        }
        this.stage = Object.assign(Object.assign({}, this.stage), { error, timing: this.getTiming() });
        debug('Connection error in stage', this.stage.typeName);
        this.ruleActions.evaluateRules(this.stage);
        this.reportActions.report(this.stage, this.remediationData);
    }
    blockRemediation() {
        this.remediationData.blocked = true;
    }
    timeoutRemediation(remediation) {
        if (!remediation) {
            return;
        }
        const { duration } = remediation;
        this.remediationData.timeout = { duration };
    }
    retryRemediation(remediation, attempt) {
        if (!remediation) {
            return;
        }
        const { retryType, delay, attempts } = remediation;
        this.remediationData.retry = { delay, attempt, maxAttempts: attempts, type: retryType };
    }
    report() {
        this.reportActions.report(this.stage, this.remediationData);
    }
    expectStage(type) {
        var _a, _b;
        if (((_a = this.stage) === null || _a === void 0 ? void 0 : _a.typeName) !== type) {
            throw new errors_1.InternalError(`Expecting to be in stage '${type}' but was in stage '${(_b = this.stage) === null || _b === void 0 ? void 0 : _b.typeName}'`);
        }
    }
    parseBody(body, headers) {
        const encoding = headers_1.getHeaderValue(headers, 'Content-Encoding');
        const contentType = headers_1.getHeaderValue(headers, 'Content-Type');
        try {
            return body_1.parse({ body, encoding, contentType, maxBodySize: this.maxBodySize });
        }
        catch (e) {
            if (e instanceof errors_1.BodyParsingError) {
                return { value: e.message, size: e.bodySize };
            }
            throw e;
        }
    }
    getTiming() {
        const endedAt = Date.now();
        return {
            endedAt,
            startedAt: this.startedAt,
            duration: endedAt - this.startedAt
        };
    }
}
exports.StageManager = StageManager;
/**
 * Typing
 */
var Protocol;
(function (Protocol) {
    Protocol["Http"] = "http";
    Protocol["Https"] = "https";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
